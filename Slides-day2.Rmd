---
title: "Introduction to Solving Biological Problems Using R - Day 2"
author: Mark Dunning, Suraj Menon and Aiora Zabala. Original material by Robert Stojnić,
  Laurent Gatto, Rob Foy, John Davey, Dávid Molnár and Ian Roberts
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output:
  slidy_presentation:
    footer: 'This work is licensed under the Creative Commons Attribution-ShareAlike
      2.0. COURSE HOME: cambiotraining.github.io/r-intro/'
  beamer_presentation: default
css: mystyle.css
toc: yes
---
```{r include = FALSE}
library(knitr)
opts_chunk$set(comment = NA) # eliminates hashtag from R outputs
```

## Day 2 Schedule

1. Further customisation of plots
2. Statistics
3. Data Manipulation Techniques
4. Programming in R
5. Further report writing

#1. Further customisation of plots

## Recap

- We have seen how to use `plot()`, `boxplot()` , `hist()` etc to make simple plots
- These come with arguments that can be used to change the appearance of the plot
    + `col`, `pch`
    + `main`, `xlab`, `ylab`
    + etc....
- We will now look at ways to modify the plot appearance after it has been created
- Also, how to export the graphs 



## The painter's model

- R employs a painter's model to construct it's plots
- Elements of the graph are added to the canvas one layer at a time, and the picture built up in levels.
- Lower levels are obscured by higher levels, 
    + allowing for blending, masking and overlaying of objects.
- Caution: You can't undo the changes you make to the plot

![](http://cdn.inquisitr.com/wp-content/uploads/2012/08/jesus-christ-fresco.gif)

[http://www.inquisitr.com/309687/jesus-painting-restoration-goes-wrong-well-intentioned-old-lady-destroys-100-year-old-fresco/](http://www.inquisitr.com/309687/jesus-painting-restoration-goes-wrong-well-intentioned-old-lady-destroys-100-year-old-fresco/)

## Example data

- We will re-use the patients data from yesterday:

```{r}
age    <- c(50, 21, 35, 45, 28, 31, 42, 33, 57, 62)
weight <- c(70.8, 67.9, 75.3, 61.9, 72.4, 69.9, 63.5, 
            71.5, 73.2, 64.8)
firstName  <- c("Adam", "Eve", "John", "Mary", "Peter", 
                "Paul", "Joanna", "Matthew", "David", "Sally")
secondName <- c("Jones", "Parker", "Evans", "Davis",
                "Baker","Daniels", "Edwards", "Smith", 
                "Roberts", "Wilson")

consent <- c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE,
             FALSE, TRUE, FALSE, TRUE)

sex <- c("Male", "Female", "Male", "Female", "Male", 
         "Male", "Female", "Male", "Male", "Female")
```

## Example data

```{r}
patients <- data.frame(First_Name = firstName, 
                       Second_Name = secondName, 
                       Full_Name = paste(firstName, secondName), 
                       Sex = factor(sex),
                       Age = age,
                       Weight = weight,
                       Consent = consent,
                       stringsAsFactors = FALSE)
```



##Initial plot

- Recall our patients dataset from yesterday
    + we might want to display other characteristics on the plot, e.g. gender of individual:

```{r, fig.height=5}
plot(patients$Age, patients$Weight, pch=16)
```

##The points function

- `points()` can be used to set of points to an *existing* plot
- It requires a vector of x and y coordinates
    + These do not have to be the same length as the number of points in the initial plot:
        + Hence we can use `points()` to highlight observations
        + ...or add a set of new observations
```{r fig.height=4}
plot(patients$Age, patients$Weight, pch=16)
points(40,68, pch="X")
```

- Note that axis limits of the existing plot are not altered

## Creating a blank plot

- Often it is useful to create a blank 'canvas' with the correct labels and limits

```{r, fig.height=5}
plot(patients$Age, patients$Weight, type="n")
```

## Adding points to differentiate gender

- Selecting males using the **`==`** comparison we saw yesterday
    + Gives a `TRUE` or `FALSE` value
    + Can be used to index the data frame
    + Which means we can get the relevant Age and Weight values
```{r}
males <- patients$Sex == "Male"
```
```{r, eval=FALSE}
males
patients[males,]
patients$Age[males]
patients$Weight[males]
```

## Adding points to differentiate gender

- The points we add have to be within the `x` and `y` limits of the original plot axes, otherwise they won't be displayed

```{r, fig.height=5}
plot(patients$Age, patients$Weight, type="n")
points(patients$Age[males], patients$Weight[males], 
       pch=16, col="steelblue")

```


## Adding points to differentiate gender


    
```{r}
females <- patients$Sex == "Female"
females
patients[females,]
```

## Adding points to differentiate gender

- Again, we have to be careful that all the points are within the `x` and `y` limits
    + this is why creating the blank plot containing the limits of the data is useful

```{r, fig.height=5}
plot(patients$Age, patients$Weight, type="n")
points(patients$Age[males], patients$Weight[males],
       pch=16, col="steelblue")
points(patients$Age[females], patients$Weight[females],
       pch=16, col="orangered1")

```


##Adding points

- Each set of points can have a different colour and shape
- Axis labels and title and limits are defined by the plot
- Once you've added points to a plot, they cannot be removed
- A call to `plot` will start a new graphics window
    - or typing `dev.off()`

```{r fig.height=3,fig.width=8}
plot(patients$Age, patients$Weight, type="n")
points(patients$Age[males], patients$Weight[males],
       pch=16, col="steelblue")
points(patients$Age[females], patients$Weight[females], 
       pch=17, col="orangered1")
```




## Adding a legend

- Should also add a legend to help interpret the plot
    + use the `legend` function
    + can give x and y coordinates where legend will appear
    + also recognises shortcuts such as ***topleft*** and ***bottomright***...

```{r fig.height=3,fig.width=8}
plot(patients$Age, patients$Weight, type="n")
points(patients$Age[males], patients$Weight[males], 
       pch=16, col="steelblue")
points(patients$Age[females], patients$Weight[females],
       pch=17, col="orangered1")
legend("topleft", legend=c("M","F"), 
       col=c("steelblue","orangered1"), pch=c(16,17))
```

##Adding text

- Text can also be added to a plot in a similar manner
    + The `labels` argument specifies the text we want to add
    
```{r fig.height=4,fig.width=8}
plot(patients$Age, patients$Weight, pch=16)
text(patients$Age, patients$Weight, labels=patients$Full_Name)
```

##Adding text

- Can alter the positions so they don't interfere with the points of the graph
    
```{r fig.height=3,fig.width=8}
plot(patients$Age, patients$Weight, pch=16,
     xlim=c(10,70), ylim=c(60,75))
text(patients$Age-1, patients$Weight-0.5, 
     labels=patients$Full_Name)
```

- Alternatively, you can use the argument `adj`

## Adding lines

- To aid our interpretation, it is often helpful to add guidelines
    + `grid()` is one easy way of doing this:
```{r,fig.height=5}
plot(patients$Age, patients$Weight, pch=16)
grid(col="steelblue")
```

## Adding lines

- Can also add lines that intersect the axes:
    + `v =` for vertical lines
    + `h =` for horizontal
    + can specify multiple lines in a vector
```{r,fig.height=5}
plot(patients$Age, patients$Weight, pch=16)
abline(v=40, col="red")
abline(h=c(65,70,75), col="blue")
```


## Plot layouts

- The `par` function can be used specify the appearance of a plot
- The settings persist until the plot is closed with **`dev.off()`**
- `?par` and scroll to ***graphical parameters***
- One example is `mfrow`:
    + "multiple figures per row"
    + needs to be a vector of rows and columns:
        + e.g. a plot with one row and two columns `par(mfrow=c(1,2))`
        + don't need the same kind of plot in each cell
        
## Plot layouts    
    
```{r,fig.height=4}
par(mfrow=c(1,2))
plot(patients$Age, patients$Weight, pch=16,
     xlim=c(10,70), ylim=c(60,75))
boxplot(patients$Weight ~ patients$Sex)

```

- See also `mar` for setting the margins:
    + `par(mar=c(...))`
    
## Exporting graphs from RStudio

- When using Rstudio interactively, the easiest option is to use the *Export* button from the *Plots* panel
- Otherwise, in an R script you can use the `pdf()` function:
    + You will see that the plot does not appear in RStudio
```{r eval=FALSE}
pdf("ExampleGraph.pdf")
plot(rnorm(1:10))
```

- You need to use the `dev.off()` to stop printing graphs to the pdf and 'close' the file
      + It allows you to create a pdf document with multiple pages
```{r eval=FALSE}
dev.off()
```

- pdf is a good choice for publication as they can be imported into Photoshop, Inkscape, etc.
    - Sometimes it is easier to edit in these tools than R!
    - If it is taking too long to customise a plot in R, consider if you should be using one of these tools instead
    
## Exporting graphs from RStudio

- To save any graph you have created to a pdf, repeat the code you used to create the plot with `pdf()` before and `dev.off()` afterwards
    + you can have as many lines of code in-between as you like
    
```{r}
pdf("mygraph.pdf")
plot(patients$Age, patients$Weight, pch=16)
abline(v=40, col="red")
abline(h=c(65,70,75), col="blue")
dev.off()
```

- If no plots are appearing in RStudio, it could be you are still writing to a pdf file
    + run `dev.off()` multiple times until you see a message `cannot shut down device (the null device)`


## Exporting graphs from RStudio

- We can specify the dimensions of the plot, and other properties of the file (`?pdf`)

```{r}
pdf("ExampleGraph.pdf", width=10, height=10)
plot(rnorm(1:10))
dev.off()
```

- Other formats can be created:
    + e.g. ***png***, or others `?jpeg`
    + more appropriate for email, presentations, web page
    
```{r}
png("ExampleGraph.png")
plot(rnorm(1:10))
dev.off()
```

##Exercise: exercise5.Rmd
- Return to the weather data from yesterday:

```{r}
weather <- read.csv("ozone.csv")
```

- Using the `par` function, create a layout with three columns
- Plot Ozone versus Solar Radiation, Wind Speed and Temperature on separate graphs
    + use different colours and plotting characters on each plot
- Save the plot to a pdf
- HINT: Create the graph first in RStudio. When you're happy with it, re-run the code preceeded by the `pdf` function to save to a file
    + don't forget to use `dev.off()` to close the file

```{r echo=FALSE,fig.height=4,fig.width=10}
par(mfrow=c(1,3))
plot(weather$Solar.R,weather$Ozone,pch=16,col="lightgreen",ylab="Ozone level",xlab="Solar Radiation")
plot(weather$Wind,weather$Ozone, pch=15,col="steelblue",ylab="Ozone level", xlab="Wind Speed")
plot(weather$Temp,weather$Ozone,pch=17,col="orange", ylab="Ozone level",xlab="Temperature")

```

##Exercise: exercise5.Rmd

- Temperature and Ozone level seem to be correlated
- However, there are some observations that do not seem to fit the trend
    + those with Ozone level > 100
- Modify the plot so that these outlier observations are in a different colour

```{r fig.height=5}
plot(weather$Temp,weather$Ozone, pch=17,
     col="orange", ylab="Ozone level",
     xlab="Temperature")
```

## Target graph

HINT: You can break down the problem into the following steps

- Create a blank plot
- Identify observations with ozone > 100
    + plot the corresponding Temperature and Ozone values for these in red
- Identify observations with ozone < 100
    + plot the corresponding Temperature and Ozone values for these in orange


```{r echo=FALSE, fig.height=5}
plot(weather$Temp,weather$Ozone, pch=17,
     col="orange", ylab="Ozone level",
     xlab="Temperature")
highO <- which(weather$Ozone > 100)
abline(h=100,lty=2)
points(weather$Temp[highO],weather$Ozone[highO],pch=17,col="red")
```


## Solution

```{r eval=FALSE}
pdf("ozoneCorrelations.pdf")
par(mfrow=c(1,3))
plot(weather$Solar.R, weather$Ozone, pch=16,
     col="lightgreen", ylab="Ozone level",
     xlab="Solar Radiation")
plot(weather$Wind, weather$Ozone, pch=15, 
     col="steelblue", ylab="Ozone level", 
     xlab="Wind Speed")
plot(weather$Temp,weather$Ozone, pch=17,
     col="orange", ylab="Ozone level",
     xlab="Temperature")
dev.off()
```

## Solution

If the graph looks a bit stretched...

```{r eval=FALSE}
pdf("ozoneCorrelations.pdf", width=10,height = 6)
par(mfrow=c(1,3))
plot(weather$Solar.R, weather$Ozone, pch=16,
     col="lightgreen", ylab="Ozone level",
     xlab="Solar Radiation")
plot(weather$Wind, weather$Ozone, pch=15, 
     col="steelblue", ylab="Ozone level", 
     xlab="Wind Speed")
plot(weather$Temp,weather$Ozone, pch=17,
     col="orange", ylab="Ozone level",
     xlab="Temperature")
dev.off()
```


## Solution: solution-exercise5.pdf

```{r fig.height=5}
highO <- which(weather$Ozone > 100)
lowO <- which(weather$Ozone < 100)

plot(weather$Temp,weather$Ozone, type="n",
     ylab="Ozone level",
     xlab="Temperature")
points(weather$Temp[highO],weather$Ozone[highO],
       col="red",pch=17)
points(weather$Temp[lowO],weather$Ozone[lowO],
       col="orange",pch=17)
abline(h=100,lty=2)
```


## Alternative Solution

Defining a vector of colours and plotting characters, and over-writing particular entries

- `rep` is used to repeat a value a certain number of times

```{r}
mycol <-rep("orange",nrow(weather))
highO <- which(weather$Ozone > 100)
mycol[highO] <- "red"
mypch <- rep(17, nrow(weather))
mypch[highO] <- 18
plot(weather$Temp,weather$Ozone, 
     col=mycol, pch=mypch,ylab="Ozone level",
     xlab="Temperature")
abline(h=100,lty=2)
```

## Alternative Solution

`ifelse` is a handy function for creating a vector of values based on a logical test

```{r}
mycol <- ifelse(weather$Ozone > 100, "red","orange")
mypch <- ifelse(weather$Ozone > 100, 18,17)

plot(weather$Temp,weather$Ozone, 
     col=mycol, pch=mypch,ylab="Ozone level",
     xlab="Temperature")
abline(h=100,lty=2)
```


# 2. Statistics
##Built-in support for statistics
- R is a statistical programming language:
    + Classical statistical tests are built-in
    + Statistical modeling functions are built-in
    + Regression analysis is fully supported
    + Additional mathematical packages are available (`MASS`, Waves, sparse matrices, etc)
  
##Distribution functions  
- Most commonly used distributions are built-in, functions have stereotypical names, e.g. for normal distribution:
    + **`pnorm`** - cumulative distribution for x
    + **`qnorm`** - inverse of pnorm (from probability gives x)
    + **`dnorm`** - distribution density
    + **`rnorm`** - random number from normal distribution
  
![distributions](images/distributions.png)  
  
- Available for variety of distributions: `punif` (uniform), `pbinom` (binomial), `pnbinom` (negative binomial), `ppois` (poisson), `pgeom` (geometric), `phyper` (hyper-geometric), `pt` (T distribution), pf (F distribution) 

##Distribution functions 
- 10 random values from the Normal distribution with mean 10 and standard deviation 5:
```{r eval=FALSE}
rnorm(10, mean=10, sd=5)
```
- The probability of drawing exactly 10 from this distribution:
```{r}
dnorm(10, mean=10, sd=5)
```

```{r}
dnorm(100, mean=10, sd=5)
```

##Distribution functions (continued)

- The probability of drawing a value smaller than 10:
```{r}
pnorm(10, mean=10, sd=5)
```
- The inverse of `pnorm()`:
```{r}
qnorm(0.5, mean=10, sd=5)
```
- How many standard deviations for statistical significance?
```{r}
qnorm(0.95, mean=0, sd=1)
```

## Example

Recall our histogram of Wind Speed from yesterday:

- The data look to be roughly normally-distributed
- An assumption we rely on for various statistical tests

```{r fig.height=4}
hist(weather$Wind, col="purple", xlab="Wind Speed",
     main="Distribution of Wind Speed",
     breaks = 20, freq=FALSE)
```

## Create a normal distribution curve

- If our data are normally-distributed, we can calculate the probability of drawing particular values.
      + e.g. a Wind Speed of 10

```{r eval=FALSE}
tempMean <- mean(weather$Wind)
tempSD <- sd(weather$Wind)
dnorm(10, mean=tempMean, sd=tempSD)
```

```{r echo=FALSE}
tempMean <- mean(weather$Wind)
tempSD <- sd(weather$Wind)
```

- We can overlay this on the histogram using `points` as we just saw:
```{r fig.height=4}
hist(weather$Wind, col="purple", xlab="Wind Speed",
     main="Distribution of Wind Speed",
     breaks = 20, freq=FALSE)
points(10, dnorm(10, mean=tempMean, sd=tempSD),
       col="red", pch=16)
```


## Create a normal distribution curve

- We can repeat the calculation for a vector of values
    + remember that functions in R are often ***vectorized***
    + use `lines` in this case rather than `points`
    
    ```{r eval=FALSE}
xs <- c(0,5,10,15,20)
ys <- dnorm(xs, mean=tempMean, sd=tempSD)
lines(xs, ys, col="red")
```

```{r fig.height=4,echo=FALSE}
hist(weather$Wind,col="purple",xlab="Wind Speed",
     main="Distribution of Wind Speed",breaks = 20,freq=FALSE)
xs <- c(0,5,10,15,20)
ys <- dnorm(xs, mean=tempMean,sd=tempSD)
lines(xs,ys,col="red")
```

## Create a normal distribution curve

- For a smoother curve, use a longer vector:
    + we can generate x values using the `seq()` function
- Inspecting the data in this manner is usually acceptable to assess normality
    + the fit doesn't have to be exact
    + the shapiro test is also available `?shapiro.test`

```{r eval=FALSE}
xs <- seq(00,20, length.out = 10000)
ys <- dnorm(xs, mean=tempMean, sd=tempSD)
lines(xs, ys, col="red")
```

```{r fig.height=4,echo=FALSE}
hist(weather$Wind,col="purple",xlab="Wind Speed",
     main="Distribution of Wind Speed",breaks = 20,freq=FALSE)
xs <- seq(00,20, length.out = 10000)
ys <- dnorm(xs, mean=tempMean,sd=tempSD)
lines(xs,ys,col="red")
```

## Simple testing

- If we want to compute the probability of observing a particular Wind Speed, from the same distribution, we can use the standard formula to calculate a t statistic:

$$t = \frac{\bar{x} -\mu_0}{s / \sqrt(n)}$$

- Say a Wind Speed of 2; which from the histogram seems to be unlikely

```{r}
t <- (tempMean - 2) / (tempSD/sqrt(length(weather$Wind)))
t
```

## Simple testing

- ...or use the **`t.test()`** function to compute the statistic and corresponding p-value

```{r}
t.test(weather$Wind, mu=2)
```


##Two-sample tests: Basic data analysis

- Comparing 2 variances:
    + Fisher's F test
```{r eval=FALSE}
var.test()
```
- Comparing 2 sample means with normal errors:
    + Student's t test
```{r eval=FALSE}
t.test()
```
- Comparing 2 means with non-normal errors:
    + Wilcoxon's rank test
```{r eval=FALSE}
wilcox.test()
```

##Two-sample tests: Basic data analysis
- Comparing 2 proportions:
    + Binomial test
    + e.g. [here](http://www.r-tutor.com/elementary-statistics/inference-about-two-populations/comparison-two-population-proportions)
    
```{r eval=FALSE}
prop.test()
```
- Correlating 2 variables:
    + Pearson's / Spearman's rank correlation
```{r eval=FALSE}
cor.test()
```
- Testing for independence of 2 variables in a contingency table:
    + Chi-squared / Fisher's exact test
```{r eval=FALSE}
chisq.test(); fisher.test()
```

## Statistical tests in R

- Bottom-line: Pretty much any statistical test you care to name will probably be in R
    + This is not supposed to be a statistics course (sorry!)
    + None of them are particular harder than others to use
    + The difficulty is deciding which test to use:
        + whether the assumptions of the test are met, etc.
    + Consult your local statistician if not sure
    + An upcoming course that will help
        + [Introduction to Statistical Analysis](http://bioinformatics-core-shared-training.github.io/IntroductionToStats/)
    + Some good references:
        + [Statistical Analysis Using R (Course from the Babaraham Bioinformatics Core)](http://training.csx.cam.ac.uk/bioinformatics/event/1827771)
        + [Quick-R guide to stats](http://www.statmethods.net/stats/index.html)
        + [Simple R eBook](https://cran.r-project.org/doc/contrib/Verzani-SimpleR.pdf)
        + [R wiki](https://en.wikibooks.org/wiki/R_Programming/Descriptive_Statistics)
        + [R tutor](http://www.r-tutor.com/elementary-statistics)
        + [Statistical Cheatsheet](https://rawgit.com/bioinformatics-core-shared-training/intermediate-stats/master/cheatsheet.pdf)

## Example analysis

- We have already seen that men in our `patients` dataset tend to be heavier than women
- We can **test this formally** in R

```{r echo=FALSE,fig.height=5}
par(mfrow=c(1,2))
plot(patients$Age, patients$Weight,pch=16,type="n")
points(patients$Age[males], patients$Weight[males],pch=16,col="steelblue")
points(patients$Age[females], patients$Weight[females],pch=17,col="orangered1")
legend("topleft", legend=c("M","F"), 
       col=c("steelblue","orangered1"), pch=c(16,17))
boxplot(patients$Weight~patients$Sex)
```

  
## Test variance assumption

```{r}
var.test(patients$Weight~patients$Sex)
```

## Perform the t-test

```{r}
t.test(patients$Weight~patients$Sex, var.equal=TRUE)
```

- This function can be tuned in various ways (`?t.test`):
    - Assumed equal variances, or not (and use Welch's correction)
    - Deal with paired samples
    - Two-sided, or one-sided p-value

##Linear regression: Basic data analysis

- Linear modeling is supported by the function **`lm()`**:
    + `example(lm)` 
    + The output assumes you know a fair bit about the subject

- `lm` is really useful for plotting lines of best fit to XY data, in order to determine intercept, gradient and Pearson's correlation coefficient
    + This is very easy in R

- Three steps to plotting with a best fit line:
    1. Plot XY scatter-plot data
    2. Fit a linear model
    3. Add bestfit line data to plot with `abline()` function
  
##Typical linear regression analysis: Basic data analysis

-  The ~ (***tilde***) is used to define a ***formula***; i.e. "y is given by x"

 
```{r fig.height=5}
x <- c(1, 2.3, 3.1, 4.8, 5.6, 6.3)
y <- c(2.6, 2.8, 3.1, 4.7, 5.1, 5.3)
plot(x,y, xlim=c(0,10), ylim=c(0,10))
```


##Typical linear regression analysis: Basic data analysis

 The ~ is used to define a formula; i.e. "y is given by x"
- Take care about the order of x and y in the plot and lm expressions

```{r,fig.height=5}
plot(x,y, xlim=c(0,10), ylim=c(0,10))
myModel <- lm(y~x)
abline(myModel, col="red")
```

## In-depth summary

```{r}
summary(myModel)
```


##Typical linear regression analysis: Basic data analysis
- Get the coefficients of the fit from:
```{r, eval=FALSE}
coef(myModel)   # Coefficients
resid(myModel)  # Residuals
fitted(myModel) # Fitted values
names(myModel)  # Names of the objects within myModel
residuals(myModel) + fitted(myModel) # what values does this give?
```

## Diagnostic plots of the fit

- Get QC of fit from:
    + Some explanation is given [here](http://data.library.virginia.edu/diagnostic-plots/) and [here](http://strata.uga.edu/6370/rtips/regressionPlots.html)
    
```{r,fig.height=5}
par(mfrow=c(2,2)) 
plot(myModel)
```

##Modelling formulae
- R has a very powerful formula syntax for describing statistical models
- Suppose we had two explanatory variables `x` and `z`, and one response
variable `y`
- We can describe a relationship between, say, `y` and `x` using a tilde `~`,
placing the response variable on the left of the tilde and the explanatory variables on the right:
    + `y~x`
- It is very easy to extend this syntax to do multiple regressions, ANOVAs, to include interactions, and to do many other common modelling tasks. For example
```{r eval=FALSE}
y~x       #If x is continuous, this is linear regression
y~x       #If x is categorical, ANOVA
y~x+z     #If x and z are continuous, multiple regression
y~x+z     #If x and z are categorical, two-way ANOVA
y~x+z+x:z # : is the symbol for the interaction term
y~x*z     # * is a shorthand for x+z+x:z
```


## Exercise: exercise6.Rmd

- There are suggestions that Ozone level could be influenced by Temperature:

```{r echo=FALSE,fig.height=4}
plot(weather$Temp, weather$Ozone,xlab="Temperature",ylab="Ozone level",pch=16)
```

- Perform a linear regression analysis to assess this:
    + Fit the linear model and print a summary of the output
    + Plot the two variables and overlay a best-fit line
    + What is the equation of the best-fit line in the form
        + $$ y = mx + c$$
    + Calculate the correlation between the two variables using the function `cor` (`?cor`)
        + can you annotate the plot with the correlation coefficient?
    
## Solution: solution-exercise6.pdf
```{r fig.show=FALSE}
mod1 <- lm(weather$Ozone~weather$Temp)
summary(mod1)
```

## Solution
```{r}
plot(weather$Temp, weather$Ozone, pch=16)
abline(mod1, col="red", lty=2)
c = coef(mod1)
text(95,150, paste("y = ", round(c[2],2), "x",round(c[1],2),sep=""))
```

## Solution
```{r}
plot(weather$Temp, weather$Ozone, pch=16)
abline(mod1, col="red", lty=2)
cor = cor(weather$Temp,weather$Ozone,use="c")
cor
text(95,150, paste("r^2 = ", round(cor^2,2)))
```

## Solution
```{r}
plot(weather$Temp, weather$Ozone, pch=16)
abline(mod1, col="red", lty=2)
cor = cor(weather$Temp,weather$Ozone,use="c")
cor
text(95,150, substitute(paste(r^2, "=" ,x),list(x=round(cor^2,2))))
```


## Word of caution

***Correlation != Causation***

![](images/spurious.png)

http://tylervigen.com/spurious-correlations

## Word of caution

![](images/screen shot 2014-04-20 at 11.06.28 am.png.jpeg)

[So if I want to win a nobel prize, I should eat even more chocolate?!?!?](http://www.businessinsider.com/chocolate-consumption-vs-nobel-prizes-2014-4?IR=T)

But no-one would ever take such trends seriously....would they?

## Wrong!

![Cutting-down on Ice Cream was recommended as a safeguard against polio!](images/icecreamvspolio.jpg)


# 3. Data Manipulation Techniques

## Motivation

- So far we have been lucky that all our data have been in the same file:
    + This is not usually the case
    + Dataset may be spread over several files
        + This takes longer, and is harder, than many people realise
    + We need to combine before doing an analysis



## Combining data from multiple sources: Gene Clustering Example

- R has powerful functions to combine heterogeneous data sources into a single data set
- Gene clustering example data:
    + Gene expression values in ***gene.expression.txt***
    + Gene information in ***gene.description.txt***
    + Patient information in ***cancer.patients.txt***
- A breast cancer dataset with numerous patient characteristics:
    + We will concentrate on ***ER status*** (positive / negative)
    + What genes show a statistically-significant different change between ER groups?


```{r echo=FALSE}

if(!file.exists("gene.expression.txt")){

  if(!require(breastCancerNKI) | require(genefilter)) {
    source("http://www.bioconductor.org/biocLite.R")
    biocLite(c("breastCancerNKI","genefilter"))
  }
  data("nki")
  cancer.patients <- pData(nki)[,c("samplename","age","er","grade")]
  genes <- fData(nki)[,c("probe","HUGO.gene.symbol","Cytoband")]
  
  exprs(nki) <- exprs(nki)[!is.na(genes$HUGO.gene.symbol),]
  
  genes <- genes[!is.na(genes$HUGO.gene.symbol),]
  
  ##get the top50 DE genes, plus 500 random
  ps <- NULL
  for(i in 1:nrow(genes)){
    ps[i] <- t.test(exprs(nki)[i,] ~ factor(cancer.patients$er))$p.value
  }
  
  set.seed(070815)
  ind <- order(ps, decreasing = FALSE)[1:50]
  ind <- sort(c(ind, sample(setdiff(1:nrow(genes),ind),500)))
  
  evalues <- exprs(nki)[ind,]
  genes <- genes[ind,]
  library(org.Hs.eg.db) 
  
  chr <- select(org.Hs.eg.db, columns=c("CHR","CHRLOC"),keys = as.character(genes$HUGO.gene.symbol),keytype = "SYMBOL")
  genes$Chromosome <- chr[match(genes$HUGO.gene.symbol, chr[,1]),2]
  genes$Chromosome <- ifelse(!is.na(genes$Chromosome),paste0("chr", genes$Chromosome),NA)
  genes$Start <- abs(chr[match(genes$HUGO.gene.symbol, chr[,1]),3])
  
  genes <- genes[,-3]
  
  final <- !is.na(genes$Chromosome)
  genes <- genes[final,]
  evalues <- evalues[final,]    




  
  write.table(evalues, file="gene.expression.txt",quote=FALSE,sep="\t")
  write.table(genes, file="gene.description.txt",quote=FALSE,sep="\t")
  write.table(cancer.patients, file="cancer.patients.txt",quote=FALSE,sep="\t")
}
```

## Analysis goals

- We will show how to lookup a particular gene in the dataset
- Also, how to look-up genes in a given genomic region
- Assess if a given gene is differentially-expressed
- Create a heatmap to cluster the samples and reveal any subgroups in the data

## Peek at the data

```{r eval=FALSE}
evals <- read.delim("gene.expression.txt")
evals[1:2,1:5]
dim(evals)
```

```{r echo=FALSE}
evals <- read.delim("gene.expression.txt")
evals[1:2,1:5]
dim(evals)
```
- `r nrow(evals)` rows and `r ncol(evals)` columns
+ One row for each gene:
    + Rows are named according to particular technology used to make measurement
    + The names of each row can be returned by `rownames(evals)`; giving a vector
+ One column for each patient:
    + The names of each column can be returned by `colnames(evals)`; giving a vector
    
## Peek at the data

```{r}
genes <- read.delim("gene.description.txt",stringsAsFactors = FALSE)
head(genes)
dim(genes)
```


- `r nrow(genes)` rows and `r ncol(genes)` columns
- One for each gene
- Includes mapping between manufacturer ID and Gene name

## Peek at the data
```{r}
subjects <- read.delim("cancer.patients.txt",stringsAsFactors = FALSE)
head(subjects)
dim(subjects)
```

- One for each patient in the study
- Each column is a different characteristic of that patient
    + e.g. whether a patient is ER positive (value of 1) or negative (value of 0)

```{r}
table(subjects$er)
```



## Ordering and sorting

To get a feel for these data, we will look at how we can subset and order

- R allows us to do the kinds of filtering, sorting and ordering operations you might be familiar with in Excel
- For example, if we want to get information about patients that are ER negative
    + these are indicated by an entry of ***0*** in the `er` column

```{r eval=FALSE}
subjects$er == 0
```

```{r echo=FALSE}
Biobase:::selectSome(subjects$er==0)

```


## Ordering and sorting

We can do the comparison within the square brackets

- Remembering to include a `,` to index the columns as well
- Best practice to create a new variable and leave the original data frame untouched

```{r}
erNegPatients <- subjects[subjects$er == 0,]
head(erNegPatients)
```

or

```{r}
View(erNegPatients)
```


## Ordering and sorting

Sorting is supported by the **`sort()`** function

- Given a vector, it will return a sorted version of the same length

```{r eval=FALSE}
sort(erNegPatients$grade)
```

```{r echo=FALSE}
Biobase:::selectSome(sort(erNegPatients$grade),maxToShow = 20)
```


- But this is not useful in all cases
    + We have lost the extra information that we have about the patients
    
## Ordering and sorting

- Instead, we can use **`order()`**
- Given a vector, `order()` will give a set of numeric values which will give an ordered version of the vector
    + default is smallest --> largest

```{r}
myvec <- c(90,100,40,30,80,50,60,20,10,70)
myvec
order(myvec)
```

- i.e. number in position 9 is the smallest, number in position 8 is the second smallest:

```{r}
myvec[9]
myvec[8]
```

N.B. `order` will also work on character vectors 

```{r}
firstName  <- c("Adam", "Eve", "John", "Mary", "Peter", "Paul", "Joanna", "Matthew", "David", "Sally")
order(firstName)
```


## Ordering and sorting

- We can use the result of `order()` to perform a subset of our original vector
- The result is an ordered vector
```{r}
myvec.ord <- myvec[order(myvec)]
myvec.ord
```

- Implication: We can use `order` on a particular column of a data frame, and use the result to sort all the rows

## Ordering and sorting

- We might want to select the youngest ER negative patients for a follow-up study
- Here we order the `age` column and use the result to re-order the rows in the data frame

```{r}
erNegPatientsByAge <- erNegPatients[order(erNegPatients$age),]
head(erNegPatientsByAge)
```

```{r}

```

## Ordering and sorting

- can change the behaviour of `order` to be Largest --> Smallest
```{r}
erNegPatientsByAge <- erNegPatients[order(erNegPatients$age,decreasing = TRUE),]
head(erNegPatientsByAge)
```

- we can write the result to a file if we wish

```{r eval=FALSE}
write.table(erNegPatientsByAge, file="erNegativeSubjectsByAge.txt", sep="\t")
```


## Exercise: exercise7.Rmd

- Imagine we want to know information about chromosome 8 genes that have been measured.
1. Create a new data frame containing information on genes on Chromosome 8
2. Order the rows in this data frame according to start position, and write the results to a file

## Solution: solution-exercise7.pdf

```{r}
chr8Genes <- genes[genes$Chromosome=="chr8",]
head(chr8Genes)
chr8GenesOrd <- chr8Genes[order(chr8Genes$Start),]
head(chr8GenesOrd)
write.table(chr8GenesOrd, "chromosome8.gene.info.txt", sep="\t")
```

## Alternative: 

- you might find the function `subset` a bit easier to use
    + no messing around with square brackets
    + no need to remember row and column indices
    + no need for `$` operator to access columns

```{r}
chr8Genes <- subset(genes, Chromosome=="chr8")
head(chr8Genes)
```


## Retrieving data for a particular gene

 - Gene `ESR1` is known to be hugely-different between ER positive and negative patient
    + let's check that this is evident in our dataset
    + if not, something has gone wrong!
- First step is to locate this gene in our dataset
- We can use `==` to do this, but there are some alternatives that are worth knowing about

## Character matching in R

- `match()` and `grep()` are often used to find particular matches
    + CAUTION: by default, match will only return the ***first*** match!

```{r}
match("D", LETTERS)
grep("F", rep(LETTERS,2))
match("F", rep(LETTERS,2))
```

## Character matching in R

- `grep` can also do partial matching
    + can also do complex matching using "regular expressions"
    
```{r}
month.name
grep("ary",month.name)
grep("ber",month.name)
```

- `%in%` will return a logical if each element is contained in a shortened list

```{r}
month.name %in% c("May", "June")
```


## Retrieving data for a particular gene

- Find the name of the ID that corresponds to gene ***ESR1*** using `match`
    + mapping between IDs and genes is in the ***genes*** data frame
        + ID in first column, gene name in the second
- Save this ID as a variable

```{r}
ind <- match("ESR1", genes$HUGO.gene.symbol)
genes[ind,]
probe <- genes[ind,1]
probe
```


## Retrieving data for a particular gene

Now, find which row in our expression matrix is indexed by this ID

- recall that the rownames of the expression matrix are the probe IDs
- save the expression values as a variable

```{r}
match(probe, rownames(evals))
evals[match(probe, rownames(evals)), 1:10]
genevals <- evals[match(probe,rownames(evals)),]
class(genevals)
```


    
## Relating to patient characteristics

We have expression values and want to visualise them against our categorical data

- use a boxplot, for example
- however, we have to first make sure our values are treat as numeric data
- as we created the subset of a data frame, the result was also a data frame
    + use `as.numeric`


```{r}
boxplot(as.numeric(genevals) ~ subjects$er)
```

## Relating to patient characteristics

- In this case there is a clear difference, so we probably don't even need a p-value to convince ourselves of the difference
    + in real-life, we would probably test lots of genes and implement some kind of multiple-testing
    + e.g. `p.adjust` (`?p.adjust`)

```{r}
t.test(as.numeric(genevals) ~ subjects$er)

```



## Complete script

`esr1Example.Rmd`

```{r eval=FALSE}
genes    <- read.delim("gene.description.txt",stringsAsFactors = FALSE)
subjects <- read.delim("cancer.patients.txt",stringsAsFactors = FALSE)
evals    <- read.delim("gene.expression.txt")

ind      <- match("ESR1", genes[,2])
probe    <- genes[ind,1]
genevals <- evals[match(probe,rownames(evals)),]

boxplot(as.numeric(genevals) ~ subjects$er)
t.test(as.numeric(genevals) ~ subjects$er)
```

## Exercise: exercise8.Rmd

Repeat the same steps we performed for the gene ESR1, but for GATA3:

- Try and make as few changes as possible from the ESR1 script
- Can you see why making a markdown document is useful for analysis?

#4. Programming in R

## Motivation

From the previous exercise, you should see how we can easily adapt our markdown scripts:

- e.g. ESR1 versus GATA3
- But what if we want to analyse many genes?
- It would be tedious to create a new markdown document for every gene
- ...and prone to error too

##Introducing loops

- Many programming languages have ways of doing the same thing many times, perhaps changing some variable each time. This is called **looping**
- Loops are not used in R so often, because we can usually achieve the same thing using vector calculations
- For example, to add two vectors together, we do not need to add each pair of elements one by one, we can just add the vectors
```{r eval=FALSE}
x <- 1:10
y <- 11:20
x+y
```
- But there are some situations where R functions can not take vectors as input. For example, `t.test()` will only test one gene at a time
- What if we wanted to test multiple genes?

##Introducing loops
- We could do this:

```{r eval=FALSE}
t.test(evals[1,] ~ factor(subjects$er))
t.test(evals[2,] ~ factor(subjects$er))

```

- But this will be boring to type, difficult to change, and prone to error
- As we are doing the same thing multiple times, but with a different index each time, we can use a **loop** instead

##Loops: Commands and flow control
- R has two basic types of loop
    + a **`for`** loop: run some code on every value in a vector
    + a **`while`** loop: run some code while some condition is true (*hardly ever used!*)
    
`for` 
```{r loops1, eval=FALSE}
for(i in 1:10) {
  print(i)
  }
```
`while` 
```{r  eval=FALSE}
i <- 1
while(i <= 10 ) {
  print(i)
  i <- i + 1
  }
```

##Loops: Commands and flow control

- Here's how we might use a `for` loop to test the first 10 genes


```{r loops2, eval=FALSE}
for(i in 1:10) {
  t.test(as.numeric(evals[i,]) ~ factor(subjects$er))
  }
```

- This is exactly the same as:

```{r eval=FALSE}
i <- 1
t.test(evals[i,] ~ factor(subjects$er))
i <- 2
t.test(evals[i,] ~ factor(subjects$er))
i <- 3
...
```



## Storing results

However, this for loop is doing the calculations but not storing the results

- The output of `t.test()` is an object with data placed in different slots
    + the `names()` of the object tells us what data we can retrieve, and what name to use
    + N.B it is a "list" object

```{r}
t <- t.test(as.numeric(evals[1,]) ~ factor(subjects$er))
names(t)
t$statistic
```

## Storing results

- When using a loop, we often create an empty "dummy" variable
- This is used store the results at each stage of the loop

```{r}
stats <- NULL
for(i in 1:10) {
  tmp <- t.test(as.numeric(evals[i,]) ~ factor(subjects$er))
  stats[i] <- tmp$statistic
  }
stats
```

## Practical application

Previously we have identified probes on chromosome 8

- Lets say that we want to do a t-test for each gene on chromosome 8
```{r}
head(chr8GenesOrd)
```

- The first step is to extract the expression values for chromosome 8 genes from our expression matrix, which has expression values for all genes
- We can use the `match` function to tell us which rows in the matrix correspond to chromosome 8 genes

```{r}
match(chr8GenesOrd$probe, rownames(evals))
chr8Expression <- evals[match(chr8GenesOrd$probe, rownames(evals)),]
dim(chr8Expression)
```


## Exercise: exercise9.Rmd

- Create a for loop to perform to test if the expression level of each gene on chromosome 8 is significantly different between ER positive and negative samples
- Store the ***p-value*** from each individual test
- How many genes have a p-value < 0.05?

## Solution: solution-exercise9.pdf

```{r}
pvals <- NULL
for(i in 1:18) {
  tmp <- t.test(as.numeric(chr8Expression[i,]) ~ factor(subjects$er))
  pvals[i] <- tmp$p.value
  }
pvals
table(pvals < 0.05)
sum(pvals < 0.05)
```

## Solution: solution-exercise9.pdf

- Our code will be more robust if we store the number of chromosome 8 genes as a variable
    + if the data change, the code should still run

```{r}
ngenes <- nrow(chr8Expression)
pvals <- NULL
for(i in 1:ngenes) {
  tmp <- t.test(as.numeric(chr8Expression[i,]) ~ factor(subjects$er))
  pvals[i] <- tmp$p.value
  }
pvals
```


##Conditional branching: Commands and flow control

- Use an `if` statement for any kind of condition testing
- Different outcomes can be selected based on a condition within brackets

```{r if, eval=FALSE}
if (condition) {
  ... do this ...
  } else {
    ... do something else ...
    }

```

- `condition` is any logical value, and can contain multiple conditions. 
    + e.g. `(a == 2 & b < 5)`, this is a compound conditional argument
- The condition should return a *single* value of `TRUE` or `FALSE`
    
    
    
## Other conditional tests

- There are various tests that can check the type of data stored in a variable
    + these tend to be called **`is...()`**. 
        + try *tab-complete* on `is.`

```{r}
is.numeric(10)
is.numeric("TEN")
is.character(10)
```

- `is.na()` is useful for seeing if an `NA` value is found
    + cannot use `== NA`!

```{r}
match("foo", genes[,2])
is.na(match("foo", genes[,2]))
```


##Conditional branching: Commands and flow control

- Using the **`for`** loop we wrote before, we could add some code to plot the expression of each gene
    + a boxplot would be ideal
- However, we might only want plots for genes with a "significant" pvalue
- Here's how we can use an `if` statement to test for this
    + for each iteration of the the loop:
        1. test if the p-value from the test is below 0.05 or not
        2. if the p-value is less than 0.05 make a boxplot
        3. if not, do nothing
        
```{r flow-control,eval=FALSE}
pdf("Chromosome8Genes.pdf")
pvals <- NULL
for (i in 1:18) {
  tmp <- t.test(as.numeric(chr8Expression[i,]) ~ factor(subjects$er))
  pvals[i] <- tmp$p.value
  if(tmp$p.value < 0.05){
    boxplot(as.numeric(chr8Expression[i,]) ~ factor(subjects$er),
            main=chr8Genes$HUGO.gene.symbol[i])
    }
  } 
pvals
dev.off()

```


##Code formatting avoids bugs!
Compare:
```{r eval=FALSE}
f<-26
while(f!=0){
print(letters[f])
f<-f-1}
```
to:
```{r eval=FALSE}
f <- 26
while(f != 0 ){
  print(letters[f])
  f <- f-1
  }
```
- The code between brackets `{}` *always* is *indented*, this clearly separates what is executed once, and what is run multiple times
- Trailing bracket `}` always alone on the line at the same indentation level as the initial bracket `{`
- Use white spaces to divide the horizontal space between units of your code, e.g. around assignments, comparisons



# 5. Report Writing


## Creating a markdown file from scratch

***File → New File → R Markdown***

- Choose 'Document' and the default output type (HTML)
- A new tab is created in RStudio
- The header allows you to specify a Page title, author and output type
```{r eval=FALSE}
---
title: "Untitled"
author: "Mark Dunning"
date: "18/08/2015"
output: html_document
---
```

## Format of the file

- **Lines 8 - 10**: Plain text description
- **Lines 12 - 14**: An R code 'chunk'
- **Lines 18 to 20**: Another code chunk, this time producing a plot

![](images/markdown-format.png)

- Pressing the ***Knit HTML*** button will create the report:
    + Note that you need to 'save' the markdown file before you will see the compiled report in your working directory
    
##Text formatting
See ***?*** → ***Markdown Quick Reference*** in RStudio:

- Enclose text in \* to format in *italics*
- Enclose text in \*\* to format in **bold**
- \*\*\* for ***bold italics***
- \` to format like `code`
- \$ to include equations: $e =mc^2$
- \> quoted text: 

>To be or not to be

- See **Help -> Markdown Quick Reference** for more:
    + Adding images
    + Adding web links
    + Tables


## Not quite enough for a reproducible document

- Minimally, you should record what version of R, and the packages you used.
- Use the `sessionInfo()` function
    + e.g. for the version of R I used to make the slides

```{r}
sessionInfo()
```
    

## Defining chunks

- It is not great practice to have one long, continuous R script
- Better to break-up into smaller pieces; '*chunks*'
- You can document each chunk separately
- Easier to catch errors
- The characteristics of each chunk can be modified:
    + You might not want to print the R code for each chunk
    + ...or the output
    + etc.


## Chunk options

Code chunks are encapsulated between backticks. Options for the chunk can be put inside the curly brackets`{...}`

```
'''{r}
my code here...
'''
```

- It's a good idea to name each chunk
    + Easier to track-down errors
- We can display R code, but not run it
    + `eval=FALSE`
- We can run R code, but not display it
    + `echo=FALSE`
    + e.g. setting display options
- Suppress warning messages
    + `warning=FALSE`

    
## Chunk options: eval

- Sometimes we want to format code for display, but not execute; we want to show the code for how we read our data, but want our report to compile quickly

```
'''{r, eval=FALSE}
data <- read.delim("path.to.my.file")
'''
```


## Chunk options: echo

- Might want to load some data from disk
    + e.g. the R object from reading the data in the previous slide
```
'''{r echo=FALSE}
load("mydata.rda")
'''
```
- or your P.I. wants to see your results, but doesn't really want to know about the R code that you used

## Chunk options: results

- Some code or functions might produce lots of output to the screen that we don't need
    + `results='hide'`
```{r results='hide'}
for(i in 1:100) {
  print(i)
  }
```


##Chunk options: message and warning

- Loading an R package will sometimes print messages and / or warnings to the screen
- This is not always helpful in a report:
```
'''{r}
library(DESeq)
'''
```

```{r echo=FALSE}
library(DESeq)
```

##Chunk options: message and warning

- Using `message=FALSE` and `warning=FALSE`
```
'''{r message=FALSE, warning=FALSE}
library(DESeq)
'''
```
- Could also need `suppressPackageStartupMessages`

##Chunk options: cache

- The argument `cache=TRUE` will stop certain chunks from being evaluate if their code does not change
- It speeds-up the compilation of the document
    + we don't want to reload our dataset if we've only made a tiny change downstream
```
'''{r echo=FALSE, cache=TRUE}
load("mydata.rda")
'''
```

## Running R code from the main text

- We can add R code to our main text, which gets evaluated
    + make sure we always have the latest figures, p-values etc

```
'''
...the sample population consisted of 'r table(gender)[1]' females 
and 'r table(gender)[2]' males...
'''
```
```{r echo=FALSE}
gender <- c(rep("F", 47), rep("M", 50))
```
...the sample population consisted of  `r table(gender)[1]` females and `r table(gender)[2]` males...

- Alternatively:

```
'''
...the p-value of the t-test is 'r pval', which indicates that...
'''
```
```{r echo=FALSE}
pval <- 0.05
```
...the p-value of the t-test is `r pval`, which indicates that...

- We call this **"in-line" code**

## Running R code from the main text

- Like the rest of our report these R statements will get updated each time we compile the report

```
'''
...the sample population consisted of 'r table(gender)[1]' females
and 'r table(gender)[2]' males...
'''
```

```{r echo=FALSE}
gender <- c(rep("F", 41), rep("M", 54))
```
...the sample population consisted of `r table(gender)[1]` females and `r table(gender)[2]` males...



```
'''
...the p-value of the t-test is 'r pval', which indicates that...
'''
```
```{r echo=FALSE}
pval <- 0.1
```
...the p-value of the t-test is `r pval`, which indicates that...


## Making a heatmap

- A heatmap is often used to visualise how the expression level of a set of genes vary between conditions
- Making the plot is actually quite straightforward
    + providing you have processed the data appropriately!
    + here, we use `na.omit()` to ensure we have no `NA` values
    
```{r}
genelist <- c("ESR1", "NAT1", "SUSD3","SLC7A2" ,"SCUBE2")
probes   <- na.omit(genes[match(genelist, genes[,2]), 1])
exprows  <- match(probes, rownames(evals))

heatmap(as.matrix(evals[exprows,]))
  

```

## Heatmap adjustments

- We can provide a colour legend for the samples
- Adjust colour of cells

```{r}
library(RColorBrewer)
sampcol <- rep("blue", ncol(evals))
sampcol[subjects$er == 1 ] <- "yellow"
rbPal <- brewer.pal(10, "RdBu")
heatmap(as.matrix(evals[exprows,]), ColSideColors = sampcol, col=rbPal)
```

- see also
    + `heatmap.2` from `library(gplots)`; `example(heatmap.2)`
    + `heatmap.plus` from `library(heatmap.plus)`; `example(heatmap.plus)`


## Exercise

This analysis is recorded in `exercise10.Rmd`.

- Use in-line R code to report how many patients were involved in the study
- Hide the code chunk used to produce the plot 
- Cache the code chunk used to read the raw data 
- Print the version of R, and version numbers of all packages, used to do the analysis

Solution: solution-exercise10.pdf

# End of Course

## Wrap-up

- **Thanks for your attention**
- Practice, practice, practice
    + ... & persevere
- Need inspiration? R code is freely-available, so read other people's code!
    + Read [blogs](http://www.r-bloggers.com/)
    + Follow the [forums](http://stackoverflow.com/questions/tagged/r)
    + Download [datasets](http://vincentarelbundock.github.io/Rdatasets/datasets.html) to practice with
    + Bookmark some [reference](https://en.wikibooks.org/wiki/R_Programming) guides
    + on twitter @rstudio, @Rbloggers, @RLangTip
    + Attend the [follow-on course](http://training.csx.cam.ac.uk/bioinformatics/event/1800066) on data manipulation and graphics
- Please fill in the feedback form for us to improve the course
    
